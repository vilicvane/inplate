import escapeStringRegexp from 'escape-string-regexp';

import type {CommentStyle} from './comment.js';
import {Handlebars} from './handlebars.js';
import {addIndent, removeIndent} from './utils.js';

const AT_INPLATE = '@inplate';
const AT_INPLATE_LINE = '@inplate-line';
const AT_PLATE = '@plate';
const AT_END = '@end';

/** Spaces */
const S = '[ \\t]*';
/** One or more spaces */
const OMS = '[ \\t]+';
/** Single space */
const SS = '[ \\t]';
/** New line */
const NL = '\\r?\\n';

export function updateContent(
  fileContent: string,
  data: object,
  commentStyles: CommentStyle[],
): string {
  const {pattern, patternMetadataArray} = buildInplatePatterns(commentStyles);

  const newLine = (fileContent.match(/\r?\n/) || ['\n'])[0];

  fileContent = fileContent.replace(pattern, (...groups) => {
    for (const {
      template: templateIndexes,
      beforeContent: beforeContentIndexes,
      afterContent: afterContentIndexes,
      indent: indentIndexes,
      decoder,
      encoder,
      escape: toEscape,
      commentPattern,
    } of patternMetadataArray) {
      let template = templateIndexes
        .map(index => groups[index])
        .find(template => typeof template === 'string');

      if (typeof template !== 'string') {
        continue;
      }

      if (commentPattern) {
        template = template.replace(commentPattern, '');
      }

      if (decoder) {
        template = decoder(template);
      }

      template = removeIndent(template);

      const beforeContent =
        beforeContentIndexes
          .map(index => groups[index])
          .find(content => typeof content === 'string') || '';
      const afterContent =
        afterContentIndexes
          .map(index => groups[index])
          .find(content => typeof content === 'string') || '';
      const indent =
        indentIndexes
          .map(index => groups[index])
          .find(content => typeof content === 'string') || '';

      template = addIndent(template, indent);

      if (!template.endsWith(newLine)) {
        template += newLine;
      }

      let content = Handlebars.compile(template, {noEscape: !toEscape})(data, {
        allowProtoPropertiesByDefault: true,
      });

      if (encoder) {
        content = encoder(content);
      }

      if (!afterContent && content.trim().split('\n').length > 1) {
        throw new Error(
          'Content generated by `@inplate-line` template can have only one line',
        );
      }

      return `${beforeContent}${content}${afterContent}`;
    }

    return groups[0];
  });

  return fileContent;
}

type PatternMetadata = {
  template: number[];
  beforeContent: number[];
  afterContent: number[];
  indent: number[];
  decoder?: (content: string) => string;
  encoder?: (content: string) => string;
  escape?: boolean;
  commentPattern?: RegExp;
};

function buildInplatePatterns(commentStyles: CommentStyle[]): {
  pattern: RegExp;
  patternMetadataArray: PatternMetadata[];
} {
  /*
    // @inplate
    // {{template}}
    // @plate
    generated content
    // @end

    // @inplate {{template}}
    generated content
    // @end

    // @inplate-line {{template}}
    generated content

    <!-- @inplate {{template}} -->
    generated content
    <!-- @end -->

    <!-- @inplate
      {{template}}
      {{template}}
    -->
    generated content
    <!-- @end -->
  */

  const patternMetadataArray: PatternMetadata[] = [];
  const patternSources: string[] = [];

  let groupCount = 0;

  for (const {
    opening,
    closing,
    decoder,
    encoder,
    escape: toEscape = false,
  } of commentStyles) {
    const openingSource = escapeStringRegexp(opening);
    const closingSource = closing && escapeStringRegexp(closing);

    let patternSource: string;

    const templateIndexes: number[] = [];
    const beforeContentIndexes: number[] = [];
    const afterContentIndexes: number[] = [];
    const indentIndexes: number[] = [];

    let commentPattern: RegExp | undefined;

    if (closingSource) {
      patternSource = [
        '(?:',
        `^((${S})${openingSource}\\s*${AT_INPLATE}(?:${S}${NL}|${OMS})([^]+?)${S}${closingSource}${S}${NL})`,
        //         <!--                @inplate                        {{template}} -->
        '[^]*?',
        `^(${S}${openingSource}\\s*${AT_END}${S}${closingSource})`,
        //       <!--                @end         -->
        ')|(?:',
        `^((${S})${openingSource}${S}${AT_INPLATE_LINE}${SS}${S}(.+?)${S}${closingSource}${S}${NL})`,
        //         <!--                @inplate-line             {{template}} -->
        `.*(?:${NL})?`,
        ')',
      ].join('');

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      afterContentIndexes.push(++groupCount);

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
    } else {
      patternSource = [
        '(?:',
        [
          '(',
          `^(${S})${openingSource}${S}${AT_INPLATE}${S}${NL}((?:^${S}${openingSource}.*${NL})+)${S}${openingSource}${S}${AT_PLATE}${S}${NL}`,
          //        #                   @inplate         \n            #             {{template}} \n multi #             @plate         \n
          '|',
          `^(${S})${openingSource}${S}${AT_INPLATE}${SS}${S}(.+?)${S}${NL}`,
          //        #                   @inplate             {{template}} \n
          ')',
        ].join(''),
        '[^]*?',
        `^(${S}${openingSource}${S}${AT_END}${S})$`,
        //       #                   @end
        ')|(?:',
        `^((${S})${openingSource}${S}${AT_INPLATE_LINE}${SS}${S}(.+?)${S}${NL})`,
        //         #                   @inplate-line             {{template}} \n
        `.*(?:${NL})?`,
        ')',
      ].join('');

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      afterContentIndexes.push(++groupCount);

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);

      commentPattern = new RegExp(`^${S}${openingSource}`, 'gm');
    }

    patternSources.push(patternSource);

    patternMetadataArray.push({
      template: templateIndexes,
      beforeContent: beforeContentIndexes,
      afterContent: afterContentIndexes,
      indent: indentIndexes,
      decoder,
      encoder,
      escape: toEscape,
      commentPattern,
    });
  }

  const pattern = new RegExp(
    patternSources.map(source => `(?:${source})`).join('|'),
    'gm',
  );

  return {
    pattern,
    patternMetadataArray,
  };
}

export function generateContentWithTemplate(
  fileName: string,
  template: string,
  data: object,
): string {
  return Handlebars.compile(template, {
    noEscape: !/\.(?:html?|hbs)$/.test(fileName),
  })(data, {allowProtoPropertiesByDefault: true});
}
