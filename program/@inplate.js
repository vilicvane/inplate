import escapeStringRegexp from 'escape-string-regexp';

import {Handlebars} from './@handlebars.js';
import {addIndent, removeIndent} from './@utils.js';

const HTML_FILE_EXTENSION_REGEX = /\.(?:html?|hbs)$/;

/** Spaces */
const S = '[ \\t]*';
/** One or more spaces */
const OMS = '[ \\t]+';
/** Single space */
const SS = '[ \\t]';

const AT_INPLATE = '@inplate';
const AT_INPLATE_LINE = '@inplate-line';
const AT_PLATE = '@plate';
const AT_END = '@end';

export function updateContent(fileContent, data, commentStyles) {
  const {regex, regexMetadataArray} = buildInplateRegex(commentStyles);

  const newLine = (fileContent.match(/\r?\n/) || ['\n'])[0];

  fileContent = fileContent.replace(regex, (...groups) => {
    for (const {
      template: templateIndexes,
      beforeContent: beforeContentIndexes,
      afterContent: afterContentIndexes,
      indent: indentIndexes,
      decoder,
      encoder,
      escape: toEscape,
      commentRegex,
    } of regexMetadataArray) {
      let template = templateIndexes
        .map(index => groups[index])
        .find(template => typeof template === 'string');

      if (typeof template !== 'string') {
        continue;
      }

      if (commentRegex) {
        template = template.replace(commentRegex, '');
      }

      if (decoder) {
        template = decoder(template);
      }

      template = removeIndent(template);

      const beforeContent = beforeContentIndexes
        .map(index => groups[index])
        .find(content => typeof content === 'string');
      const afterContent =
        afterContentIndexes
          .map(index => groups[index])
          .find(content => typeof content === 'string') || '';
      const indent = indentIndexes
        .map(index => groups[index])
        .find(content => typeof content === 'string');

      template = addIndent(template, indent);

      if (!template.endsWith(newLine)) {
        template += newLine;
      }

      let content = Handlebars.compile(template, {noEscape: !toEscape})(data, {
        allowProtoPropertiesByDefault: true,
      });

      if (encoder) {
        content = encoder(content);
      }

      if (!afterContent && content.trim().split('\n').length > 1) {
        throw new Error(
          'Content generated by `@inplate-line` template can have only one line',
        );
      }

      return `${beforeContent}${content}${afterContent}`;
    }
  });

  return fileContent;
}

function buildInplateRegex(commentStyles) {
  /*
    // @inplate
    // {{template}}
    // @plate
    generated content
    // @end

    // @inplate {{template}}
    generated content
    // @end

    // @inplate-line {{template}}
    generated content

    <!-- @inplate {{template}} -->
    generated content
    <!-- @end -->

    <!-- @inplate
      {{template}}
      {{template}}
    -->
    generated content
    <!-- @end -->
  */

  const regexMetadataArray = [];
  const regexSources = [];

  let groupCount = 0;

  for (const {
    opening,
    closing,
    decoder,
    encoder,
    escape: toEscape = false,
  } of commentStyles) {
    const openingSource = escapeStringRegexp(opening);
    const closingSource = closing && escapeStringRegexp(closing);

    let regexSource;
    const templateIndexes = [];
    const beforeContentIndexes = [];
    const afterContentIndexes = [];
    const indentIndexes = [];
    let commentRegex;

    if (closingSource) {
      regexSource = [
        '(?:',
        `^((${S})${openingSource}\\s*${AT_INPLATE}(?:${S}\\r?\\n|${OMS})([^]+?)${S}${closingSource}${S}\\r?\\n)`,
        //         <!--                @inplate                          {{template}} -->
        '[^]*?',
        `^(${S}${openingSource}\\s*${AT_END}${S}${closingSource})`,
        //       <!--                @end         -->
        ')|(?:',
        `^((${S})${openingSource}${S}${AT_INPLATE_LINE}${SS}${S}(.+?)${S}${closingSource}${S}\\r?\\n)`,
        //         <!--                @inplate-line             {{template}} -->
        '.*(?:\\r?\\n)?',
        ')',
      ].join('');

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      afterContentIndexes.push(++groupCount);

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
    } else {
      regexSource = [
        '(?:',
        [
          '(',
          `^(${S})${openingSource}${S}${AT_INPLATE}${S}\\r?\\n((?:^${S}${openingSource}.*\\r?\\n)+)${S}${openingSource}${S}${AT_PLATE}${S}\\r?\\n`,
          //        #                   @inplate           \n            #             {{template}} \n multi #               @plate           \n
          '|',
          `^(${S})${openingSource}${S}${AT_INPLATE}${SS}${S}(.+?)${S}\\r?\\n`,
          //        #                   @inplate             {{template}} \n
          ')',
        ].join(''),
        '[^]*?',
        `^(${S}${openingSource}${S}${AT_END}${S})$`,
        //       #                   @end
        ')|(?:',
        `^((${S})${openingSource}${S}${AT_INPLATE_LINE}${SS}${S}(.+?)${S}\\r?\\n)`,
        //         #                   @inplate-line             {{template}} \n
        '.*(?:\\r?\\n)?',
        ')',
      ].join('');

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);
      afterContentIndexes.push(++groupCount);

      beforeContentIndexes.push(++groupCount);
      indentIndexes.push(++groupCount);
      templateIndexes.push(++groupCount);

      commentRegex = new RegExp(`^${S}${openingSource}`, 'gm');
    }

    regexSources.push(regexSource);

    regexMetadataArray.push({
      template: templateIndexes,
      beforeContent: beforeContentIndexes,
      afterContent: afterContentIndexes,
      indent: indentIndexes,
      decoder,
      encoder,
      escape: toEscape,
      commentRegex,
    });
  }

  const regex = new RegExp(
    regexSources.map(source => `(?:${source})`).join('|'),
    'gm',
  );

  return {
    regex,
    regexMetadataArray,
  };
}

export function generateContentWithTemplate(fileName, template, data) {
  return Handlebars.compile(template, {
    noEscape: !HTML_FILE_EXTENSION_REGEX.test(fileName),
  })(data, {allowProtoPropertiesByDefault: true});
}
